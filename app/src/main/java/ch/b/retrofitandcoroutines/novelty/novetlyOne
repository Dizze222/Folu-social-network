Во время написания этого проекта я узнал:

О существовании инвариантности, ковариантности, контравариантности

1) Инвариантность -> типы в дженериках должны совпадать/находиться в одной иерархии,
то есть Инвариантность обязует использовать тот тип, который мы указали в дженерике
class Container<T>(var contained: T)
val container: Container<Int> = Container<Int>(25) - success

val container: Container<Number> = Container<Int>(25) - error

2)Ковариантность -> используется для приведение общих типов к более конкретным
Для работы с коваринтными типами используют out

class A <out T>(val contained: T){
val container: Container<Any> = Container<Int>(25)

3)Контрвариантность -> приведение из конкретных типов, в общие

in - позволяет работать с контрвариантностью

fun main() {
val cats: Pushable<Cat> = Stack<Animal>()

}
abstract class Animal(){

}
class Cat : Animal(){

}

interface Pushable<in T> where T: Animal{
    fun Push(T: Any)
}

class Stack<T> : Pushable<T> where T: Animal {
    override fun Push(T: Any) {

    }

}
